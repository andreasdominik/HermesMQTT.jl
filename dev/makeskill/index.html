<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>New skill tutorial · hermesMQTT.jl</title><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img src="../assets/logo.svg" alt="hermesMQTT.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../">hermesMQTT.jl</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Introduction</a></li><li><a class="tocitem" href="../install/">Installation</a></li><li><a class="tocitem" href="../details/">Some details</a></li><li class="is-active"><a class="tocitem" href>New skill tutorial</a><ul class="internal"><li><a class="tocitem" href="#Set-up-the-framework"><span>Set up the framework</span></a></li><li><a class="tocitem" href="#Define-the-intents"><span>Define the intents</span></a></li><li><a class="tocitem" href="#Generate-the-skeleton-a-new-project"><span>Generate the skeleton a new project</span></a></li><li><a class="tocitem" href="#Add-implementation"><span>Add implementation</span></a></li><li><a class="tocitem" href="#Example-with-low-level-API"><span>Example with low-level API</span></a></li></ul></li><li><a class="tocitem" href="../api/">API Reference</a></li><li><a class="tocitem" href="../license/">License</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>New skill tutorial</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>New skill tutorial</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/andreasdominik/HermesMQTT.jl/blob/main/docs/src/makeskill.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="How-to-write-a-new-skill"><a class="docs-heading-anchor" href="#How-to-write-a-new-skill">How to write a new skill</a><a id="How-to-write-a-new-skill-1"></a><a class="docs-heading-anchor-permalink" href="#How-to-write-a-new-skill" title="Permalink"></a></h1><p>Because of the fact that all HermesMQTT skills are executed within the same Julia process, there is some more overhead in the code of the skills compared to standalone Python skills.</p><p>To support skill development, the framework comes with a generator  script, that creates a skill-skeleton that already is functional without the need of wrinting any code manually.</p><p>This brief tutorials guides through the process of making a new skill using the generator script:</p><h2 id="Set-up-the-framework"><a class="docs-heading-anchor" href="#Set-up-the-framework">Set up the framework</a><a id="Set-up-the-framework-1"></a><a class="docs-heading-anchor-permalink" href="#Set-up-the-framework" title="Permalink"></a></h2><p>See section <em>Installation</em> for details.  Let us assume, <code>HermesMQTT</code> is installed at <code>/opt/HermesMQTT/</code>.</p><h2 id="Define-the-intents"><a class="docs-heading-anchor" href="#Define-the-intents">Define the intents</a><a id="Define-the-intents-1"></a><a class="docs-heading-anchor-permalink" href="#Define-the-intents" title="Permalink"></a></h2><p>It is a good idea, to start skill development in the <em>Rhasspy</em> console (aka web interface) and define the intents  by adding slots and intents to the sentences file or (better) add a new sentences file for each skill.</p><p>This way, it is possible to train the speech-to-text engine and  test all wanted commands <em>and</em> to see all generated JSON payloads which your new skill may need to read.</p><h2 id="Generate-the-skeleton-a-new-project"><a class="docs-heading-anchor" href="#Generate-the-skeleton-a-new-project">Generate the skeleton a new project</a><a id="Generate-the-skeleton-a-new-project-1"></a><a class="docs-heading-anchor-permalink" href="#Generate-the-skeleton-a-new-project" title="Permalink"></a></h2><p>To generate the skill,  start a Julia REPL and run the skill-generator. The genrator will ask you for the name of the skill, the names of the intents and the names of the slots for each intent.</p><pre><code class="language-julia hljs">using HermesMQTT
HermesMQTT.generate_skill() # or HermesMQTT.generate_skill(&quot;SkillName&quot;)</code></pre><p>The generator asks you to enter</p><ul><li>the skill name (if not given as argument),</li><li>one by one the intent names for the skill,</li><li>for each intent, the needed slot names.</li></ul><p>The generated skill is functional out of the box. When the HermesMQTT-framework is restarted, it will load the new skill. Because the intents are already defined in <em>Rhasspy</em>, they can be tested instantly.</p><p>Of course, the actual implementation of the skill is missing, but if called by the voice command, the new skill will prove that it is alive by telling  you it&#39;s name and names and values for all recognised slots.</p><h2 id="Add-implementation"><a class="docs-heading-anchor" href="#Add-implementation">Add implementation</a><a id="Add-implementation-1"></a><a class="docs-heading-anchor-permalink" href="#Add-implementation" title="Permalink"></a></h2><p>The actual implementation fo the skill can be added by modifying the  action-functions for each intent. These functions are located in the file <code>Your_Skill/Skill/skill-actions.jl</code> and have the signatures <code>&lt;intentname&gt;_action(topic, payload)</code>.</p><p>It is easy to change the dummy-implementation into whatever is needed.</p><h3 id="Files-in-the-sceleton"><a class="docs-heading-anchor" href="#Files-in-the-sceleton">Files in the sceleton</a><a id="Files-in-the-sceleton-1"></a><a class="docs-heading-anchor-permalink" href="#Files-in-the-sceleton" title="Permalink"></a></h3><p>Although all custom implementation can be done in the file <code>skill-actions.jl</code>, the created skeleton consists of several files.  These may be modified, if wanted:</p><table><tr><th style="text-align: right">filename</th><th style="text-align: right">comment</th><th style="text-align: right">needs to be adapted</th></tr><tr><td style="text-align: right"><code>loader-MyFire.jl</code></td><td style="text-align: right">generated loader function for the framework</td><td style="text-align: right">no</td></tr><tr><td style="text-align: right"><code>config.ini</code></td><td style="text-align: right">ini file as default</td><td style="text-align: right">yes</td></tr><tr><td style="text-align: right"><code>api.jl</code></td><td style="text-align: right">source code of Julia low-level API for a controlled device</td><td style="text-align: right">optional</td></tr><tr><td style="text-align: right"><code>config.jl</code></td><td style="text-align: right">global initialisation of a skill</td><td style="text-align: right">optional</td></tr><tr><td style="text-align: right"><code>exported.jl</code></td><td style="text-align: right">generated exported functions of the skill module</td><td style="text-align: right">no</td></tr><tr><td style="text-align: right"><code>skill-actions.jl</code></td><td style="text-align: right">functions to be executed, if an intent is recognised</td><td style="text-align: right">yes</td></tr><tr><td style="text-align: right"><code>MyFire.jl</code></td><td style="text-align: right">the julia module for the skill</td><td style="text-align: right">no</td></tr></table><p>In a minimum-setup only 2 things need to be adapted for a new skill:</p><ul><li>the action-functions which respond to an intent (the <em>direct</em> action, no callback) must be defined and implemented (in <code>skill-actions.jl</code>)</li><li>settings and sentences to be utterd  in the <code>config.ini</code>-file</li></ul><p>Optionally, more fine-grained software engineering is possible by</p><ul><li>separating the user-interaction from the API of controlled devices  (the latter might go to <code>api.jl</code>).</li><li>and by using different intents, depending on the language defined in <code>config.ini</code>.</li></ul><h2 id="Example-with-low-level-API"><a class="docs-heading-anchor" href="#Example-with-low-level-API">Example with low-level API</a><a id="Example-with-low-level-API-1"></a><a class="docs-heading-anchor-permalink" href="#Example-with-low-level-API" title="Permalink"></a></h2><p>This tutorial shows how a skill to control an external device can be derived from the template.</p><p>The idea is to control an Amazon fire stick with a minimum set of commands <code>on, off, play, pause</code>. More commands can be implement easily the same way.</p><p>Switching on and off is implemented based on the common on-off-intent, included in the framework.</p><h3 id="The-Amazon-fire-low-level-API"><a class="docs-heading-anchor" href="#The-Amazon-fire-low-level-API">The Amazon fire low-level API</a><a id="The-Amazon-fire-low-level-API-1"></a><a class="docs-heading-anchor-permalink" href="#The-Amazon-fire-low-level-API" title="Permalink"></a></h3><p>The low-level API which sends commands to the Amazon fire is borrowed from Matt&#39;s ADBee project (<code>git@github.com:mattgyver83/adbee.git</code>) that provides a shell-script to send commands to the Amazon device. Please read there for the steps to prepare the Amazon device for the remote control via ADB.</p><p>Although Python programmes usually find Python packages for every task, it is a very good idea to implement the lowest level of any device-control API as a shell script. Advantages:</p><ul><li>easy to write</li><li>fast and without any overhead</li><li>easy to test: the API can be tested by running the script from the commandline as <code>controlFire ON</code> or <code>controlFire OFF</code> and see what happens.</li></ul><p>The simplified ADBee-script is:</p><pre><code class="language-sh hljs">#!/bin/bash -xv
# control fireTv via adb

COMMANDS=$@
IP=amazon-fire  # set to 192.168.1.200 by dhcp
PORT=5555
ADB=adb
SEND_KEY=&quot;$ADB -s $IP:$PORT shell input keyevent&quot;

adb connect amazon-fire

for CMD in $COMMANDS ; do
  case $CMD in
    wake)
      $SEND_KEY KEYCODE_WAKEUP
      ;;
    sleep)
      $SEND_KEY KEYCODE_POWER
      ;;
    play)
      $SEND_KEY KEYCODE_MEDIA_PLAY_PAUSE
      ;;
    pause)
      $SEND_KEY KEYCODE_MEDIA_PLAY_PAUSE
      ;;
    # more commands may go here ...
  esac
done</code></pre><p>Once this script is tested, the Julia API can be set up.</p><h3 id="The-Julia-API"><a class="docs-heading-anchor" href="#The-Julia-API">The Julia API</a><a id="The-Julia-API-1"></a><a class="docs-heading-anchor-permalink" href="#The-Julia-API" title="Permalink"></a></h3><p>By default the API goes into the file api.jl, which is empty in the template.</p><p>In this case only a wrapper is needed, to make the API-commands available in the Julia program. The framework provide a function <code>tryrun()</code> to execute external commands safely (i.e. if an error occures, the program will not crash, but reading the error message via Hermes text-to-speech).</p><p>This API definition splits in the function to execute the ADBee-script and functions to be called by the user:</p><pre><code class="language-Julia hljs">function adbCmds(cmds)

    return tryrun(`$ADB $(split(cmds))`, errorMsg =
            &quot;&quot;&quot;An error occured while sending commands $cmds
            to Amazon fire.&quot;&quot;&quot;
end




function amazonON()
    adbCmds(&quot;wake&quot;)
end

function amazonOFF()
    adbCmds(&quot;sleep&quot;)
end

function amazonPlay()
    adbCmds(&quot;play&quot;)
end

function amazonPause()
    adbCmds(&quot;pause&quot;)
end</code></pre><h3 id="The-skill-action-for-on/off"><a class="docs-heading-anchor" href="#The-skill-action-for-on/off">The skill-action for on/off</a><a id="The-skill-action-for-on/off-1"></a><a class="docs-heading-anchor-permalink" href="#The-skill-action-for-on/off" title="Permalink"></a></h3><p>This functions are executed by the framework if an intent is recognised. The functions are defined in the file <code>skill-actions.jl</code>. On/off is handled via the common on/off-intent. All other actions need a specific intent, that must be set up in the Snips console.</p><p>The constants <code>DEVICE_NAME</code> and <code>SLOT_NAME</code>, used in the example,  can be defined somewhere (by default constants are defined in <code>config.jl</code>):</p><pre><code class="language-Julia hljs">&quot;&quot;&quot;
    power_on_off(topic, payload)

Power on or of with HermesMQTT mechanism.
&quot;&quot;&quot;
function power_on_off(topic, payload)

    if is_on_off_matched(payload, DEVICE_NAME) == :on
        publish_end_session(&quot;I wake up the Amazon Fire Stick.&quot;)
        amazonON()
        return true

    elseif is_on_off_matched(payload, DEVICE_NAME) == :off
        publish_end_session(&quot;I send the Amazon Fire Stick to sleep.&quot;)
        amazonOFF()
        return true

    else
        return false
    end
end</code></pre><p>Returning <code>false</code> will disable the <em>continue without hotword</em> function; i.e. a hotword is necessary before the next command can be uttered. This is necessary for the default-case, because probably a different app will execute this non-recognised command.</p><h3 id="The-skill-action-for-all-other-commands"><a class="docs-heading-anchor" href="#The-skill-action-for-all-other-commands">The skill-action for all other commands</a><a id="The-skill-action-for-all-other-commands-1"></a><a class="docs-heading-anchor-permalink" href="#The-skill-action-for-all-other-commands" title="Permalink"></a></h3><p>All other commands must be handled by an intent that you must create in the Rhasspy console. Let&#39;s assume the intent has the name <code>MyFire</code> and delivers the command in the slot <code>Command</code>. The slot should know all known commands with synonyms.</p><p>If the intend have not been already generated, a  skill-action has to be defined in the file <code>skill-actions.jl</code>:</p><pre><code class="language-Julia hljs">&quot;&quot;&quot;
    action_commands(topic, payload)

Send commands to Amamzon device.
&quot;&quot;&quot;
function action_commands(topic, payload)

    if is_in_slot(SLOT_NAME, &quot;play&quot;)
        publish_end_session(&quot;I play the current selection!&quot;)
        amazonPlay()
        return true

    elseif is_in_slot(SLOT_NAME, &quot;pause&quot;)
        publish_end_session(&quot;I pause the movie.&quot;)
        amazonPause()
        return true

    else
        publish_end_session(&quot;I cannot respond!&quot;)
        return true
    end
end</code></pre><h3 id="Tying-everything-together"><a class="docs-heading-anchor" href="#Tying-everything-together">Tying everything together</a><a id="Tying-everything-together-1"></a><a class="docs-heading-anchor-permalink" href="#Tying-everything-together" title="Permalink"></a></h3><p>The last step is to tell the skill the names of intents to listen to and the names of the slots to extract values from. Both is defined in the file <code>config.jl</code>:</p><ul><li>The slot names are simply defined as global constants (they are only global within the module MyFire).</li><li>Intents and respective functions are stored in the background and registered with the function <code>register_intent_action()</code>. (the generator script is doing this registration for you)</li></ul><pre><code class="language-Julia hljs">const SLOT_NAME = &quot;Command&quot;
const DEVICE_NAME = &quot;amazon_fire&quot;

...

register_on_off_action(power_on_off)
register_intent_action(&quot;MyFire&quot;, action_commands)</code></pre><p>Once the functuions are registered together with the intents, the framework will execute the functions.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../details/">« Some details</a><a class="docs-footer-nextpage" href="../api/">API Reference »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.24 on <span class="colophon-date" title="Thursday 23 February 2023 11:13">Thursday 23 February 2023</span>. Using Julia version 1.6.7.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
