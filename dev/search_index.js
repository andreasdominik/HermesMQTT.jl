var documenterSearchIndex = {"docs":
[{"location":"todo/","page":"-","title":"-","text":"Time defs:","category":"page"},{"location":"todo/","page":"-","title":"-","text":"SetAlarm mir wecker für{tag} auf (((viertel vor):-15)|((viertel nach):15)|(halb:-30)|:0){minute} (1..23) {stunde} uhr mir wecker (für | auf) ((heute |):heute | morgen | übermorgen | rhasspy/days){tag} auf{stunde} uhr (0..59){minute}","category":"page"},{"location":"api/#API-documentation","page":"API Reference","title":"API documentation","text":"","category":"section"},{"location":"api/#Hermes-functions","page":"API Reference","title":"Hermes functions","text":"","category":"section"},{"location":"api/","page":"API Reference","title":"API Reference","text":"These functions publish and subscribe to Hermes MQTT-topics.","category":"page"},{"location":"api/","page":"API Reference","title":"API Reference","text":"subscribe_to_intents\nsubscribe_to_topics\npublish_start_session_action\npublish_start_session_notification\npublish_end_session\npublish_hotword_on\npublish_hotword_off","category":"page"},{"location":"api/#HermesMQTT.subscribe_to_intents","page":"API Reference","title":"HermesMQTT.subscribe_to_intents","text":"subscribe_to_intents(intents, callback; moreTopics = nothing)\n\nSubscribe to one or a list of intents and listen forever and run the callback if a matching intent is recieved.\n\nArguments:\n\nintents: Abstract String or List of Abstract Strings to define          intents to subscribe. The intents will be expanded          to topics (i.e. \"hermes/intent/SwitchOnLight\")\ncallback: Function to be executed for a incoming message\nmoreTopics: keyword arg to provide additional topics to subscribe           (complete names of of topics).\n\nDetails:\n\nThe callback function has the signature f(topic, intentMessage), where topic is a String and intentMessage a Dict{Symbol, Any} with the content of the payload (assuming, that the payload is in JSON-format) or a String, if the payload is not valid JSON. The callback function is spawned and the function is listening to the MQTT server while the callback is executed.\n\n\n\n\n\n","category":"function"},{"location":"api/#HermesMQTT.subscribe_to_topics","page":"API Reference","title":"HermesMQTT.subscribe_to_topics","text":"subscribe_to_topics(topics, callback)\n\nSubscribe to one or a list of topics and listen forever and run the callback if a matching intent is recieved.\n\nArguments:\n\ntopics: Abstract String or List of Abstract Strings to define          topics to subscribe.\ncallback: Function to be executed for a incoming message\n\nSee subscribe2Intents() for details.\n\n\n\n\n\n","category":"function"},{"location":"api/#HermesMQTT.publish_start_session_action","page":"API Reference","title":"HermesMQTT.publish_start_session_action","text":"publish_start_session_action(text; siteID=get_siteID(),\n     intentFilter=nothing, sendIntentNotRecognized=false,\n     customData=nothing)\n\nMQTT publish start session with init action\n\nArguments:\n\nsiteID: ID of the site in which the session is started\ntext: text to be said via TTS\nintentFilter: Optional Array of String - a list of intent names to               restrict the NLU resolution of the answer of this query.\nsendIntentNotRecognized: Optional Boolean -  Indicates whether the               dialogue manager should handle non recognized intents               by itself or sent them as an Intent Not Recognized for               the client to handle.\ncustomData: data to be sent to the service.\n\n\n\n\n\n","category":"function"},{"location":"api/#HermesMQTT.publish_start_session_notification","page":"API Reference","title":"HermesMQTT.publish_start_session_notification","text":"publish_start_session_notification(text; siteID=get_siteID(),\n                                customData=nothing)\n\nMQTT publish start session with init notification\n\nArguments:\n\nsiteID: siteID\ntext: text to be said via TTS\ncustomData: data to be sent to the service.\n\n\n\n\n\n","category":"function"},{"location":"api/#HermesMQTT.publish_end_session","page":"API Reference","title":"HermesMQTT.publish_end_session","text":"publish_end_session(text...; sessionID=get_sessionID())\n\nMQTT publish end session.\n\nArguments:\n\nsessionId: ID of the session to be terminated as String.            If omitted, sessionId of the current will be inserted.\ntext: text to be said via TTS\n\n\n\n\n\n","category":"function"},{"location":"api/#HermesMQTT.publish_hotword_on","page":"API Reference","title":"HermesMQTT.publish_hotword_on","text":"function publish_hotword_on(siteID)\n\nPublish a hotword-on topic for the siteID.\n\nArguments:\n\nsiteID: mandatory argument siteID must be given as String (no default)\n\n\n\n\n\n","category":"function"},{"location":"api/#HermesMQTT.publish_hotword_off","page":"API Reference","title":"HermesMQTT.publish_hotword_off","text":"function publish_hotword_off(siteID)\n\nPublish a hotword-off topic for the siteId.\n\nArguments:\n\nsiteID: mandatory argument siteId must be given as String (no default)\n\n\n\n\n\n","category":"function"},{"location":"api/#Dialogue-manager-functions","page":"API Reference","title":"Dialogue manager functions","text":"","category":"section"},{"location":"api/","page":"API Reference","title":"API Reference","text":"In addition to functions to work with the dialogue manager, advanced direct dialogues are provided that can be included in the control flow of the program.","category":"page"},{"location":"api/","page":"API Reference","title":"API Reference","text":"publish_continue_session\nlisten_intents_one_time\nconfigure_intent\nask_yes_or_no_or_unknown\nask_yes_or_no\npublish_say\npublish_nlu_query\npublish_intent","category":"page"},{"location":"api/#HermesMQTT.publish_continue_session","page":"API Reference","title":"HermesMQTT.publish_continue_session","text":"publish_continue_session(text...; sessionID=get_sessionID(),\n     intentFilter = nothing,\n     customData = nothing, sendIntentNotRecognized = false)\n\nMQTT publish continue session.\n\nArguments:\n\nsessionID: ID of the current session as String\ntext: text to be said via TTS\nintentFilter: Optional Array of String - a list of intents names to               restrict the NLU resolution on the answer of this query.\ncustomData: Optional String - an update to the session's custom data.\nsendIntentNotRecognized: Optional Boolean -  Indicates whether the               dialogue manager should handle non recognized intents               by itself or sent them as an Intent Not Recognized for               the client to handle.\n\n\n\n\n\n","category":"function"},{"location":"api/#HermesMQTT.configure_intent","page":"API Reference","title":"HermesMQTT.configure_intent","text":"configure_intent(intent, on)\n\nEnable or disable an intent.\n\nintent: one intent to be configured\non: boolean value; if true, the intent is enabled; if false it is disabled.\n\n\n\n\n\n\n\n","category":"function"},{"location":"api/#HermesMQTT.ask_yes_or_no","page":"API Reference","title":"HermesMQTT.ask_yes_or_no","text":"ask_yes_or_no(question)\n\nAsk the question and listen to the intent \"ADoSnipsYesNoDE\" and return :true if \"Yes\" or \"No\" otherwise.\n\nArguments:\n\nquestion: String with the question to uttered\n\n\n\n\n\n","category":"function"},{"location":"api/#HermesMQTT.publish_say","page":"API Reference","title":"HermesMQTT.publish_say","text":"publish_say(text...; sessionID=get_sessionID(), siteID=nothing,\n                lang=nothing, id=nothing, wait=true)\n\nLet the TTS say something.\n\nThe variant with a Symbol as first argument looks up the phrase in the dictionary of phrases for the selected language by calling getText().\n\nArguments:\n\ntext: text to be said via TTS\nlang: optional language code (i.e. en-US) to use when saying the text.       If not specified, default language will be used\nsessionId: optional ID of the session if there is one\nid: optional request identifier. If provided, it will be passed back     in the response on hermes/tts/sayFinished.\nwait: wait until the massege is spoken (i.e. wait for the       MQTT-topic)\n\n\n\n\n\n","category":"function"},{"location":"api/#HermesMQTT.publish_nlu_query","page":"API Reference","title":"HermesMQTT.publish_nlu_query","text":"publishnluquery(input; siteID=\"default\", sessionID=nothing,                                 intentFilter=nothing)\n\nPublish a NLU request for the command input.\n\n\n\n\n\n","category":"function"},{"location":"api/#HermesMQTT.publish_intent","page":"API Reference","title":"HermesMQTT.publish_intent","text":"publish_intent(payload, topic=nothing)\n\nPublish an intent with the payload as topic.\n\n\n\n\n\n","category":"function"},{"location":"api/#Interaction-with-assistant-Rhasspy/Susi/Snips","page":"API Reference","title":"Interaction with assistant Rhasspy/Susi/Snips","text":"","category":"section"},{"location":"api/","page":"API Reference","title":"API Reference","text":"get_language","category":"page"},{"location":"api/#HermesMQTT.get_language","page":"API Reference","title":"HermesMQTT.get_language","text":"get_language()\n\nReturn the language in the Module HermesMQTT\n\n\n\n\n\n","category":"function"},{"location":"api/#Functions-to-handle-intents","page":"API Reference","title":"Functions to handle intents","text":"","category":"section"},{"location":"api/","page":"API Reference","title":"API Reference","text":"register_intent_action\nget_intent_actions\nset_intent_actions\nis_false_detection","category":"page"},{"location":"api/#HermesMQTT.register_intent_action","page":"API Reference","title":"HermesMQTT.register_intent_action","text":"register_intent_action(intent, inModule, action)\nregister_intent_action(intent, action)\n\nAdd an intent to the list of intents to subscribe to. Each function that shall be executed if Snips recognises an intent must be registered with this function. The framework will collect all these links, subscribe to all needed intents and execute the respective functions. The links need not to be unique (in both directions): It is possible to assign several functions to one intent (all of them will be executed), or to assign one function to more then one intent.\n\nThe variant with only (intent, action) as arguments applies the current DEVEL_NAME and MODULE as stored in the framework. The variants registerIntent... create topics with prefix hermes/intent/developer:intent.\n\nArguments:\n\nintent: Name of the intend (without developer name)\ndeveloper: Name of skill developer\ninModule: current module (can be accessed with @__MODULE__)\naction: the function to be linked with the intent\n\n\n\n\n\n","category":"function"},{"location":"api/#HermesMQTT.get_intent_actions","page":"API Reference","title":"HermesMQTT.get_intent_actions","text":"get_intent_actions()\n\nReturn the list of all intent-function mappings for this app. The function is exported to deliver the mappings to the Main context.\n\n\n\n\n\n","category":"function"},{"location":"api/#HermesMQTT.set_intent_actions","page":"API Reference","title":"HermesMQTT.set_intent_actions","text":"setIntentActions(intent_actions)\n\nOverwrite the complete list of all intent-function mappings for this app. The function is exported to get the mappings from the Main context.\n\nArguments:\n\nintent_actions: Array of intent-action mappings as Tuple of                (intent::AbstractString, developer::AbstractString,                 inModule::Module, action::Function)\n\n\n\n\n\n","category":"function"},{"location":"api/#HermesMQTT.is_false_detection","page":"API Reference","title":"HermesMQTT.is_false_detection","text":"is_false_detection(payload)\n\nReturn true, if the current intent is not correct for the uttered command (i.e. false positive).\n\nArguments:\n\npayload: Dictionary with the payload of a recognised intent.\n\nDetails:\n\nAll lines of the config.ini are analysed, witch match expressions:\n\n`<intentname>:must_include:<description>=<list of words>\n\nAn example would be:\n\nswitchOnOff:must_include = on, light\nswitchOnOff:must_chain = light,on\nswitchOnOff:must_span = switch,light,on\nswitchOnOff:must_span = switch,on\n\nThe command must include all words in the correct order of at least one parameter lines and the words must span the complete line (i.e. the command starts with first word and ends with the last word of the list).\n\nSeveral lines are possible; the last part of the parameter name is used as description and to make the parameter names unique.\n\n\n\n\n\n","category":"function"},{"location":"api/#config.ini-functions","page":"API Reference","title":"config.ini functions","text":"","category":"section"},{"location":"api/","page":"API Reference","title":"API Reference","text":"Helper functions for read values from the file config.ini.","category":"page"},{"location":"api/","page":"API Reference","title":"API Reference","text":"config.ini files follow the normal rules as for all Snips apps, with some extensions:","category":"page"},{"location":"api/","page":"API Reference","title":"API Reference","text":"spaces are allowed around the =\nthe parameter value may not contain whitespace; i.e. light=my light is better light=my_light\nif the value of the parameter (right side) includes commas, the value can be interpreted as a comma-separated list of values. In this case, the reader-function will return an array of Strings with the values (which an be accessed by their index).\nparameter names may have a prefix (set by the function  set_config_prefix()). If set, all config-functions will try to find parameter names with prefix. Example: If the config.ini includes the lines:\nmain_light:ip=192.168.0.15\nwall_light:ip=192.168.0.16\nthe following code returns 192.168.0.15 in the first call and 192.168.0.16 in the second. This makes it easy to delegate config-reads to sub-functions:\nset_config_prefix(\"main_light\")\nmain_ip = get_config(\"ip\")\n\nset_config_prefix(\"wall_light\")\nwall_ip = get_config(\"ip\")\nObviously is possible to access the parameters directly via get_config(\"main_light:ip\") or get_config(Symbol(\"main_light:ip\")) without setting the prefix (the second form will work even if another prefix is set; see doc of the functions for details).","category":"page"},{"location":"api/","page":"API Reference","title":"API Reference","text":"get_config\nset_config_prefix\nreset_config_prefix\nget_all_config\nread_config\nmatch_config\nis_in_config\nis_config_valid\nget_config_path\nload_hermes_config\nload_skill_config\nload_two_configs","category":"page"},{"location":"api/#HermesMQTT.get_config","page":"API Reference","title":"HermesMQTT.get_config","text":"get_config(name; multiple = false, one_prefix = nothing,\n                skill=get_appname())\n\nReturn the parameter value of the config.ini with name or nothing if the param does not exist. Return value is of type AbstractString, if it is a single value or of type AbstractArray{AbstractString} if the a list of values is read.\n\nArguments:\n\nname: name of the config parameter as Symbol or String\nmultiple: if true an array of values is returned, even if             only a single value have been read.\none_prefix: if defined, the prefix will be used only for this             single call instead of the stored prefix.\n\nDetails:\n\nIf name is of type Symbol, it is treated as key in the Dirctionary of parameter values. If name is an AbstractString, the prefix is added if a prefix is defined (as <prefix>:<name>). 'get_config()' returns ''nothing if something is wrong.\n\nconfig.ini entries are stored with the corresponding skill name  (appname), The function calles getconfigskill() with the current appname used as skill. If a config-entry for a specific skill is wanted, the function  get_config_skill(...; skill=\"skillname\") can be used.\n\n\n\n\n\n","category":"function"},{"location":"api/#HermesMQTT.set_config_prefix","page":"API Reference","title":"HermesMQTT.set_config_prefix","text":"set_config_prefix(new_prefix)\n\nSet the prefix for all following calls to a parameter from config.ini. All parameter names, gives as Strings will be modified as <prefix>:<name>.\n\n\n\n\n\n","category":"function"},{"location":"api/#HermesMQTT.reset_config_prefix","page":"API Reference","title":"HermesMQTT.reset_config_prefix","text":"reset_config_prefix()\n\nRemove the prefix for all following calls to a parameter from config.ini.\n\n\n\n\n\n","category":"function"},{"location":"api/#HermesMQTT.get_all_config","page":"API Reference","title":"HermesMQTT.get_all_config","text":"get_all_config()\n\nReturn a Dict with the complete config.ini.\n\n\n\n\n\n","category":"function"},{"location":"api/#HermesMQTT.read_config","page":"API Reference","title":"HermesMQTT.read_config","text":"read_config(app_dir; skill=get_appname())\n\nRead the lines of the App's config file and return a Dict with config values.\n\nArguments:\n\nappDir: Directory of the currently running app.\n\n\n\n\n\n","category":"function"},{"location":"api/#HermesMQTT.match_config","page":"API Reference","title":"HermesMQTT.match_config","text":"match_config(name::Symbol, val::String; skill=get_appname())\n\nReturn true if the parameter with name name of the config.ini has the value val or one element of the list as the value val.\n\nArguments:\n\nname: name of the config parameter as Symbol or String\nval: desired value\n\n\n\n\n\n","category":"function"},{"location":"api/#HermesMQTT.is_in_config","page":"API Reference","title":"HermesMQTT.is_in_config","text":"is_in_config(name; skill=get_appname())\n\nReturn true if a parameter with name exists.\n\nArguments:\n\nname: name of the config parameter as Symbol or String\n\n\n\n\n\n","category":"function"},{"location":"api/#HermesMQTT.is_config_valid","page":"API Reference","title":"HermesMQTT.is_config_valid","text":"is_config_valid(name; regex = r\".\", elem = 1, errorMsg = ERRORS_EN[:error_config],, \n                skill=get_appname())\n\nReturn true, if the parameter name have been read correctly from the config.ini file and false otherwise. By default \"correct\" means: it is a String with length > 0. For a moore specific test, a regex can be provided.\n\nArguments:\n\nname: name of parameter as AbstractString or Symbol\nregex: optional regex for the test\nelem: element to be tested, if the parameter returns an array\nerrorMsg: alternative error message.\n\n\n\n\n\n","category":"function"},{"location":"api/#HermesMQTT.get_config_path","page":"API Reference","title":"HermesMQTT.get_config_path","text":"get_config_path(name, default_path; one_prefix = nothing,\n                skill=get_appname())\n\nRead the config value 'name' as filename and generate a full (absolute) path:\n\nif fName starts with '/', it is returned as is.\notherwise a full path is created with 'defaultPath' as prefix.\n\nArguments:\n\nname: name of the config parameter as Symbol or String\ndefault_path: path to be used if name is not already a path\none_prefix: if defined, the prefix will be used only for this             single call instead of the stored prefix.\n\n\n\n\n\n","category":"function"},{"location":"api/#HermesMQTT.load_hermes_config","page":"API Reference","title":"HermesMQTT.load_hermes_config","text":"load_hermes_config(hermes_dir)\n\nLoad config setting for the HermesMQTT framework.\n\nArguments:\n\nhermes_dir: path to the HermesMQTT-config.ini              .../Skills/HermesMQTT.jl\n\n\n\n\n\n","category":"function"},{"location":"api/#HermesMQTT.load_skill_config","page":"API Reference","title":"HermesMQTT.load_skill_config","text":"load_skill_config(app_dir)\n\nLoad config setting for a skill.\n\nArguments:\n\napp_dir: path to the config.ini              .../Skills/Skill\n\n\n\n\n\n","category":"function"},{"location":"api/#HermesMQTT.load_two_configs","page":"API Reference","title":"HermesMQTT.load_two_configs","text":"load_two_configs(app_dir, hermes_dir=nothing, skill=get_appname())\n\nLoad config setting for a skill in dir app_dir and config of the HermesMQTTframework fromapp_dir/../HermesMQTT/config.ini` or the specified dir.\n\nArguments:\n\nhermes_dir: path to the HermesMQTT-config.ini              .../Skills/HermesMQTT.jl\n\n\n\n\n\n","category":"function"},{"location":"api/#Slot-access-functions","page":"API Reference","title":"Slot access functions","text":"","category":"section"},{"location":"api/","page":"API Reference","title":"API Reference","text":"Functions to read values from slots of recognised intents.","category":"page"},{"location":"api/","page":"API Reference","title":"API Reference","text":"extract_slot_value\nextract_multislot_values\nis_in_slot\nis_on_off_matched\nis_valid_or_end\nread_time_from_slot","category":"page"},{"location":"api/#HermesMQTT.extract_slot_value","page":"API Reference","title":"HermesMQTT.extract_slot_value","text":"extract_slot_value(slot_name, payload)\n\nReturn the value of a slot.\n\nNothing is returned, if\n\nno slots in payload,\nno slots with name slot_name in payload,\nno value in slot slot_name.\n\n\n\n\n\n","category":"function"},{"location":"api/#HermesMQTT.extract_multislot_values","page":"API Reference","title":"HermesMQTT.extract_multislot_values","text":"extract_multislot_values(slot_names,payload)\n\nReturn a list with all values of a list of slots.\n\nNothing is returned, if\n\nno slots in payload,\nno slots with name in slotNames in payload,\nno values in slot slotNames.\n\n\n\n\n\n","category":"function"},{"location":"api/#HermesMQTT.is_in_slot","page":"API Reference","title":"HermesMQTT.is_in_slot","text":"is_in_slot(slot_name, value, payload)\n\nReturn true, if the value is present in the slot slotName of the JSON payload (i.e. one of the slot values must match). Return false if something is wrong (value not in payload or no slots slotName.)\n\n\n\n\n\n","category":"function"},{"location":"api/#HermesMQTT.is_on_off_matched","page":"API Reference","title":"HermesMQTT.is_on_off_matched","text":"is_on_off_matched(payload, device_name; siteID=get_siteID())\n\nAction to be combined with the Hermes ON/OFF-intent Susi:on_off. Depending on the payload the function returns:\n\n:on if \"on\"\n:off if \"off\"\n:matched, if the device is matched but no on or off\n:unmatched, if one of\nwrong siteId\nwrong device\n\nArguments:\n\npayload: payload of intent\nsiteId: siteId of the device to be matched with the payload of intent           if siteId == \"any\", the device will be matched w/o caring           about siteId or room.\ndevice_name : name of device to be matched with the payload of intent\n\n\n\n\n\n","category":"function"},{"location":"api/#HermesMQTT.is_valid_or_end","page":"API Reference","title":"HermesMQTT.is_valid_or_end","text":"is_valid_or_end(param; error_msg = \"mandatory parameter is nothing\")\n\nEnd the session, with the message, if the param is nothing and returns false or true otherwise.\n\nFunction is a shortcut:\n\nif isnothing(param)\n    publishEndSession(:error)\n    return true\nend\n\nis:\n\nis_valid_or_end(param, :error) || return true\n\nArguments:\n\nparam: any value (from slot or config.ini) that may be nothing\nerrorMsg: Error as string or key of a text in the languages Dict (::Symbol).\n\n\n\n\n\n","category":"function"},{"location":"api/#HermesMQTT.read_time_from_slot","page":"API Reference","title":"HermesMQTT.read_time_from_slot","text":"read_time_from_slot(slot_name, payload)\n\nReturn a DateTime from a slot with a time string of the format \"2019-09-03 18:00:00 +00:00\" or nothing if it is not possible to parse the slot.\n\n\n\n\n\n","category":"function"},{"location":"api/#MQTT-functions","page":"API Reference","title":"MQTT functions","text":"","category":"section"},{"location":"api/","page":"API Reference","title":"API Reference","text":"Low-level API to MQTT messages (publish and subscribe). In the QuickAndDirty framework, these functions are calling Eclipse mosquitto_pub and mosquitto_sub. However this first (and preliminary) implementation is surpriningly robust and easy to maintain - there might be no need to change.","category":"page"},{"location":"api/","page":"API Reference","title":"API Reference","text":"subscribe_MQTT\nread_one_MQTT\npublish_MQTT\npublish_MQTT_file","category":"page"},{"location":"api/#HermesMQTT.subscribe_MQTT","page":"API Reference","title":"HermesMQTT.subscribe_MQTT","text":"subscribe_MQTT(topics, callback)\n\nListen to one or more topics.\n\nArguments\n\ntopics: AbstractString or List of AbtsractString to define         topics to subscribe\ncallback: Function to be executed for a incoming message.\n\nDetails:\n\nThe callback function has the signature f(topic, payload), where topic is a String and payload a Dict{Symbol, Any} with the content of the payload (assuming, that the payload is in JSON-format) or a String, if the payload is not a valid JSON.\n\nThe callback function is spawned.\n\n\n\n\n\n","category":"function"},{"location":"api/#HermesMQTT.read_one_MQTT","page":"API Reference","title":"HermesMQTT.read_one_MQTT","text":"read_one_MQTT(topics; timeout=TIMEOUT)\n\nListen to one or more topics until one message is retrieved and return topic as string and payload as Dict or as String if JSON parsing is not possible).\n\nArguments\n\ntopics: AbstractString or List of AbstractString to define         topics to subscribe\n\n\n\n\n\n","category":"function"},{"location":"api/#HermesMQTT.publish_MQTT","page":"API Reference","title":"HermesMQTT.publish_MQTT","text":"publish_MQTT(topic, payload; file=false)\n\nPublish a MQTT message.\n\nArguments\n\ntopics: String with the topic\npayload: Dict() with message\nfile: if true, the file will be sent (via -f payload, otherwise         the payload will be sent as JSON string via -m)\n\n\n\n\n\n","category":"function"},{"location":"api/#HermesMQTT.publish_MQTT_file","page":"API Reference","title":"HermesMQTT.publish_MQTT_file","text":"publish_MQTT_file(topic, fname)\n\nPublish a MQTT message with a file as payload.\n\nArguments\n\ntopics: String with the topic\nfname: full path and name of file to be published\n\n\n\n\n\n","category":"function"},{"location":"api/#Handle-background-information-of-recognised-intent","page":"API Reference","title":"Handle background information of recognised intent","text":"","category":"section"},{"location":"api/","page":"API Reference","title":"API Reference","text":"set_siteID\nget_siteID\nset_sessionID\nget_sessionID\nset_module\nget_module\nset_appdir\nget_appdir\nset_appname\nget_appname\nset_topic\nget_topic\nset_intent\nget_intent","category":"page"},{"location":"api/#HermesMQTT.set_siteID","page":"API Reference","title":"HermesMQTT.set_siteID","text":"set_siteID(siteID)\n\nSet the siteID in the Module HermesMQTT (necessary to direct the say() output to the current room)\n\n\n\n\n\n","category":"function"},{"location":"api/#HermesMQTT.get_siteID","page":"API Reference","title":"HermesMQTT.get_siteID","text":"get_siteID()\n\nReturn the siteID in the Module HermesMQTT (necessary to direct the say() output to the current room)\n\n\n\n\n\n","category":"function"},{"location":"api/#HermesMQTT.set_sessionID","page":"API Reference","title":"HermesMQTT.set_sessionID","text":"set_sessionID(sessionID)\n\nSet the sessionId in the Module SnipsHermesQnD. The sessionId will be used to publish Hermes messages inside a runing session. The framework handles this in the background.\n\nArguments:\n\nsessionId: as String from a Hermes payload.\n\n\n\n\n\n","category":"function"},{"location":"api/#HermesMQTT.get_sessionID","page":"API Reference","title":"HermesMQTT.get_sessionID","text":"get_sessionID()\n\nReturn the sessionId of the currently running session.\n\n\n\n\n\n","category":"function"},{"location":"api/#HermesMQTT.set_module","page":"API Reference","title":"HermesMQTT.set_module","text":"set_module(currentModule)\n\nSet the module of the currently running app in SnipsHermesQnD. The framework uses this in the background.\n\nArguments:\n\ncurrentModule: The module in which the current skill is running.                (acessible via marco @__MODULE__)\n\n\n\n\n\n","category":"function"},{"location":"api/#HermesMQTT.get_module","page":"API Reference","title":"HermesMQTT.get_module","text":"get_module()\n\nReturn the module of the currently running app.\n\n\n\n\n\n","category":"function"},{"location":"api/#HermesMQTT.set_appdir","page":"API Reference","title":"HermesMQTT.set_appdir","text":"set_appdir(app_dir)\n\nStore the directory appdir as CURRENT[:app_dir] in the current session\n\n\n\n\n\n","category":"function"},{"location":"api/#HermesMQTT.get_appdir","page":"API Reference","title":"HermesMQTT.get_appdir","text":"get_appdir()\n\nReturn the directory of the currently running app\n\n\n\n\n\n","category":"function"},{"location":"api/#HermesMQTT.set_appname","page":"API Reference","title":"HermesMQTT.set_appname","text":"set_appname(app_name)\n\nStore the name of the current app/module in CURRENT.\n\n\n\n\n\n","category":"function"},{"location":"api/#HermesMQTT.get_appname","page":"API Reference","title":"HermesMQTT.get_appname","text":"get_appname()\n\nReturn the name of the currently running app.\n\n\n\n\n\n","category":"function"},{"location":"api/#HermesMQTT.set_topic","page":"API Reference","title":"HermesMQTT.set_topic","text":"set_topic(topic)\n\nSet the topic for which the currently running app is working. The framework uses this in the background.\n\nArguments:\n\ntopic: name of current topic\n\n\n\n\n\n","category":"function"},{"location":"api/#HermesMQTT.get_topic","page":"API Reference","title":"HermesMQTT.get_topic","text":"get_topic()\n\nReturn the topic of the currently running app.\n\n\n\n\n\n","category":"function"},{"location":"api/#HermesMQTT.set_intent","page":"API Reference","title":"HermesMQTT.set_intent","text":"set_intent(payload)\n\nSet the intent for which the currently running app is working. The framework uses this in the background.\n\nArguments:\n\ntopic: name of current topic\n\n\n\n\n\n","category":"function"},{"location":"api/#HermesMQTT.get_intent","page":"API Reference","title":"HermesMQTT.get_intent","text":"get_intent()\nget_intent(payload)\n\nReturn the intent name of the currently running app.\n\n\n\n\n\n","category":"function"},{"location":"api/#Multi-language-utilities","page":"API Reference","title":"Multi-language utilities","text":"","category":"section"},{"location":"api/","page":"API Reference","title":"API Reference","text":"set_language\nadd_text\nlang_text","category":"page"},{"location":"api/#HermesMQTT.set_language","page":"API Reference","title":"HermesMQTT.set_language","text":"set_language(lang)\n\nSet the language in the Module HermesMQTT\n\n\n\n\n\n","category":"function"},{"location":"api/#HermesMQTT.add_text","page":"API Reference","title":"HermesMQTT.add_text","text":"add_text(lang::AbstractString, key, text)\n\nAdd the text to the dictionary of text sniplets for the language lang and the key key.\n\nArguments:\n\nlang: String with language code (\"en\", \"de\", ...)\nkey: Symbol or string with unique key for the text\ntext: String or array of String with the text(s) to be uttered.\n\nDetails:\n\nIf text is an Array, all texts will be saved and the function J4H.lang_text() will return a randomly selected text from the list.\n\nIf the key already exists, the new text will be added to the the Array of texts for a key.\n\n\n\n\n\n","category":"function"},{"location":"api/#HermesMQTT.lang_text","page":"API Reference","title":"HermesMQTT.lang_text","text":"function lang_text(texts..., lang=get_language())\n\nJoin the elements of texts into a single string and replace each string by the sentence of the language.\n\nArguments:\n\ntexts: iterable collection of elements that can be converted          into strings. Symbols will be replaced by the          languange snipplets.\n\n\n\n\n\n","category":"function"},{"location":"api/#Hardware-control","page":"API Reference","title":"Hardware control","text":"","category":"section"},{"location":"api/","page":"API Reference","title":"API Reference","text":"Some devices can be directly controlled by the framework. In order to stay in the style of Snips, it is possible to run Shelly WiFi-switches without any cloud accounts and services. The Shelly-devices come with an own WiFi network. After installing the device just connect to Shelly's access point (somthing like shelly1-35FA58) and configure the switch for DHCP in your network with  teh selft-explaining the web-interface of the device. At no point it's necessary to create an account or use a cloud service (although the Shelly1 documentation recommends).","category":"page"},{"location":"api/","page":"API Reference","title":"API Reference","text":"set_GPIO\nswitch_shelly_1\nswitch_shelly_25_relay\nmove_shelly_25_roller","category":"page"},{"location":"api/#HermesMQTT.set_GPIO","page":"API Reference","title":"HermesMQTT.set_GPIO","text":"set_GPIO(gpio, onoff::Symbol)\n\nSwitch a GPIO on or off with pigs.\n\nArguments:\n\ngpio: ID of GPIO (not pinID)\nonoff: one of :on or :off\n\n\n\n\n\n","category":"function"},{"location":"api/#HermesMQTT.switch_shelly_1","page":"API Reference","title":"HermesMQTT.switch_shelly_1","text":"switch_shelly_1(ip, action; timer = 10)\n\nSwitch a shelly1 device with IP ip on or off, depending on the value given as action and return true, if successful.\n\nArguments:\n\nip: IP address or DNS name of Shelly1 device\naction: demanded action as symbol; one of :on, :off, push or :timer.           action :push will switch on for 200ms to simulate a push.           action :timer will switch off after timer secs.\ntimer: if action == timer, the device is switched on and          off again after timer secs (default 10s).\n\nFor the API-doc of the Shelly devices see: <https://shelly-api-docs.shelly.cloud>.\n\n\n\n\n\n","category":"function"},{"location":"api/#HermesMQTT.switch_shelly_25_relay","page":"API Reference","title":"HermesMQTT.switch_shelly_25_relay","text":"switch_shelly_25_relay(ip, relay, action; timer = 10)\n\nSwitch the relay relay of a shelly2.5 device with IP ip on or off, depending on the value given as action and return true, if successful.\n\nArguments:\n\nip: IP address or DNS name of Shelly2.5 device\nrelay: Number of relay to be switched (0 or 1)\naction: demanded action as symbol; one of :on, :off, push or :timer.           action :push will switch on for 200ms to simulate a push.           action :timer will switch off after timer secs.\ntimer: if action == timer, the device is switched on and          off again after timer secs (default 10s).\n\nFor the API-doc of the Shelly devices see: <https://shelly-api-docs.shelly.cloud>.\n\n\n\n\n\n","category":"function"},{"location":"api/#HermesMQTT.move_shelly_25_roller","page":"API Reference","title":"HermesMQTT.move_shelly_25_roller","text":"move_shelly_25_roller(ip, action; pos = 100, duration = 1)\n\nMove a roller with a shelly2.5 device with IP ip and return true, if successful.\n\nArguments:\n\nip: IP address or DNS name of Shelly2.5 device\naction: demanded action as symbol; one of :open, :close, :stop           or :to_pos.\npos: desired position in percent\n'duration': is not yet implemented.\n\nFor the API-doc of the Shelly devices see: <https://shelly-api-docs.shelly.cloud>.\n\n\n\n\n\n","category":"function"},{"location":"api/#Status-database","page":"API Reference","title":"Status database","text":"","category":"section"},{"location":"api/","page":"API Reference","title":"API Reference","text":"The framework handles a database to save status about house and devices, controlled by the assistant. The database is stored on disk in order to persist in case of a system crash or restart.","category":"page"},{"location":"api/","page":"API Reference","title":"API Reference","text":"Every skill can store and read Dicts() as entries with a unique key or values as field-value-pairs as part of an entry.","category":"page"},{"location":"api/","page":"API Reference","title":"API Reference","text":"The db looks somehow like:","category":"page"},{"location":"api/","page":"API Reference","title":"API Reference","text":"{\n    \"irrigation\" :\n    {\n        \"time\" : \"2019-08-26T10:12:13.177\"\n        \"writer\" : \"Susi:Irrigation\",\n        \"payload\" :\n        {\n            \"status\" : \"on\",\n            \"next_status\" : \"off\"\n        }\n    }\n}","category":"page"},{"location":"api/","page":"API Reference","title":"API Reference","text":"Location of the database file is <application_data_dir>/HermesMQTT/<database_file> where application_data_dir and database_file> are parameters in the config.ini of the framework.","category":"page"},{"location":"api/","page":"API Reference","title":"API Reference","text":"db_write_payload\ndb_write_value\ndb_has_entry\ndb_read_entry\ndb_read_value","category":"page"},{"location":"api/#HermesMQTT.db_write_value","page":"API Reference","title":"HermesMQTT.db_write_value","text":"db_write_value(key, field, value)\n\nWrite a field=>value pair to the entry of a database entry. The field is overwitten if the entry already exists, or created elsewise. The database is written to the JSON-file after the write.\n\nArguments\n\nkey: unique key of the database entry of        type AbstractString or Symbol\nfield: database field of the entry with key key        to be written (AbstractString or Symbol).\nvalue: value to be stored in the field, typically        a Dict() will be stored as JSON.\n\n\n\n\n\n","category":"function"},{"location":"api/#HermesMQTT.db_has_entry","page":"API Reference","title":"HermesMQTT.db_has_entry","text":"db_has_entry(key)\n\nCheck if the database has an entry with the key key and return true or false otherwise.\n\nArguments\n\nkey: unique key of the database entry of        type AbstractString or Symbol\n\n\n\n\n\n","category":"function"},{"location":"api/#HermesMQTT.db_read_entry","page":"API Reference","title":"HermesMQTT.db_read_entry","text":"db_read_entry(key)\n\nRead the complete entry with the key key from the status database and return the entry as Dict() or nothing if not in the database.\n\nArguments\n\nkey: unique key of the database entry of        type AbstractString or Symbol\n\n\n\n\n\n","category":"function"},{"location":"api/#HermesMQTT.db_read_value","page":"API Reference","title":"HermesMQTT.db_read_value","text":"db_read_value(key, field)\n\nRead the field field of the  entry with the key key from the status database and return the value or nothing if not in the database.\n\nArguments\n\nkey: unique key of the database entry of        type AbstractString or Symbol\nfield: database field of the payload of the entry with key key        (AbstractString or Symbol).\n\n\n\n\n\n","category":"function"},{"location":"api/#Scheduler","page":"API Reference","title":"Scheduler","text":"","category":"section"},{"location":"api/","page":"API Reference","title":"API Reference","text":"The framework provides a scheduler which allows to execute intents or commands at a specified time in the future.","category":"page"},{"location":"api/","page":"API Reference","title":"API Reference","text":"publish_schedule_command","category":"page"},{"location":"api/#HermesMQTT.publish_schedule_command","page":"API Reference","title":"HermesMQTT.publish_schedule_command","text":"publish_schedule_command(command, exec_time, origin; \n                siteID=get_site_id(), sessionID=mk_session_id())\n\nPublish a command to be executed at a specific time.\n\n\n\n\n\n","category":"function"},{"location":"api/#Utility-functions","page":"API Reference","title":"Utility functions","text":"","category":"section"},{"location":"api/","page":"API Reference","title":"API Reference","text":"Little helpers to provide functionality which is commonly needed when developing a skill.","category":"page"},{"location":"api/","page":"API Reference","title":"API Reference","text":"readable_date_time\nget_weather\ntryrun\nping\ntry_read_textfile\ntry_parse_JSON_file\ntry_parse_JSON\ntry_mk_JSON\nprint_log\nprint_debug","category":"page"},{"location":"api/#HermesMQTT.readable_date_time","page":"API Reference","title":"HermesMQTT.readable_date_time","text":"function readable_date_time(datetime::AbstractString; lang=get_language())\n                          wholeDay = false, onlyDay = false)\nfunction readable_date_time(datetime::DateTime; lang=get_language(),\n                          wholeDay = false, onlyDay = false)\nfunction readable_date(datetime::Date; lang=get_language())\n\nReturn human readable date and time, like \"Friday, 1. January 2018\",  \"9 15\"\n\nSupported languages: \"en\", \"de\", \"fr\".\n\nArguments:\n\ndatetime: date and optional time as ISO string or as DateTime object.\nlang: Language code (e.g. \"en\" or \"de\")\nwholeDay: boolean, if true, no time is returned, instead \"whole day\"\nonlyDay: just tell the day, not the time\nonlyTime: just tell the time, not the day\n\nValue:\n\nString value with readable date and time.\n\n\n\n\n\n","category":"function"},{"location":"api/#HermesMQTT.get_weather","page":"API Reference","title":"HermesMQTT.get_weather","text":"get_weather()\n\nReturn a Dict with weather information from openweather.org or weatherapi.com. The config.ini of the framework must include the lines to define which service to be used and api key and location for the service used (available from openweather.org or weatherapi.com).\n\n# weather_service=openweather\nweather_service=weatherapi\nopenweather:api_key=insert_valid_API-key_here\nopenweather:city_id=6350865\n\nweatherapi:api_key=insert_valid_API-key_here\nweatherapi:location=52.52,13.40\n\nValue:\n\nThe return value has the elements:\n\n:service: name of the weather service\n:pressure: pressure in hPa\n:temperature: temperature in degrees Celsius\n:windspeed: wind speed in meter/sec\n:winddir: wind direction in degrees\n:clouds: cloudiness in percent\n:rain: rain forecast for today\n:rain1h\n:rain3h: rain in mm in the last 1 or 3 hours\n:sunrise\n:sunset: local time of sunrise/sunset as DateTime object\n\nIf something went wrong with the API-service, nothing is returned.\n\n\n\n\n\n","category":"function"},{"location":"api/#HermesMQTT.tryrun","page":"API Reference","title":"HermesMQTT.tryrun","text":"tryrun(cmd; wait = true, error_msg = ERRORS_EN[:error_script], silent = false)\n\nTry to run an external command and returns true if successful or false if not.\n\nArguments:\n\ncmd: command to be executed on the shell\nwait: if true, wait until the command has finished\nerror_msg: AbstractString or key to multi-language dict with the           error message.\nsilent: if true, no error is published, if something went wrong.\n\n\n\n\n\n","category":"function"},{"location":"api/#HermesMQTT.ping","page":"API Reference","title":"HermesMQTT.ping","text":"ping(ip; c = 1, W = 1)\n\nReturn true, if a ping to the ip-address (or name) is successful.\n\nArguments:\n\nc: number of pings to send (default: 1)\nW: timeout (default 1 sec)\n\n\n\n\n\n","category":"function"},{"location":"api/#HermesMQTT.try_read_textfile","page":"API Reference","title":"HermesMQTT.try_read_textfile","text":"try_read_textfile(fname, error_msg = TEXTS[:error_read])\n\nTry to read a text file from file system and return the text as String or an String of length 0, if something went wrong.\n\n\n\n\n\n","category":"function"},{"location":"api/#HermesMQTT.try_parse_JSON_file","page":"API Reference","title":"HermesMQTT.try_parse_JSON_file","text":"try_parse_JSON_file(fname; quiet = false)\n\nParse a JSON file and return a hierarchy of Dicts with the content.\n\nkeys are changed to Symbol\non error, an empty Dict() is returned\n\nArguments:\n\nfname: filename\nquiet: if false Snips utters an error message\n\n\n\n\n\n","category":"function"},{"location":"api/#HermesMQTT.try_parse_JSON","page":"API Reference","title":"HermesMQTT.try_parse_JSON","text":"try_parse_JSON(text)\n\nparses a JSON and returns a hierarchy of Dicts{Symbol, Any} and Arrays with the content or a string (text), if text is not a valid JSON, the raw string is returned.\n\n\n\n\n\n","category":"function"},{"location":"api/#HermesMQTT.print_log","page":"API Reference","title":"HermesMQTT.print_log","text":"print_log(s)\n\nPrint the message The current App-name is printed as prefix.\n\n\n\n\n\n","category":"function"},{"location":"api/#HermesMQTT.print_debug","page":"API Reference","title":"HermesMQTT.print_debug","text":"print_debug(s)\n\nPrint the message only, if debug-mode is on. Debug-modes include\n\nnone: no debugging\nlogging: print_debug() will print\nno_parallel: logging is on and skill actions will                will not be spawned (as a result, the listener is                off-line while a skill-action is running).\n\nCurrent App-name is printed as prefix.\n\n\n\n\n\n","category":"function"},{"location":"api/#Index","page":"API Reference","title":"Index","text":"","category":"section"},{"location":"api/","page":"API Reference","title":"API Reference","text":"","category":"page"},{"location":"details/#Some-details","page":"Some details","title":"Some details","text":"","category":"section"},{"location":"details/#Strategy","page":"Some details","title":"Strategy","text":"","category":"section"},{"location":"details/","page":"Some details","title":"Some details","text":"The idea behind the framework is to put as much as possible in the background, so that a developer only needs to provide the code for the functions executed for an intent.","category":"page"},{"location":"details/","page":"Some details","title":"Some details","text":"The MQTT-messages of Hermes and the Dialogue Manager are wrapped and additional interfaces to Hermes are provided to enable direct dialogues without using callbacks.","category":"page"},{"location":"details/","page":"Some details","title":"Some details","text":"In addion background information, such as current session-ID or current site-ID, are handled in the background and are not exposed to a skill developer.","category":"page"},{"location":"details/","page":"Some details","title":"Some details","text":"Additional utilities are provided to","category":"page"},{"location":"details/","page":"Some details","title":"Some details","text":"read values from intent slots,\nread values from config.ini,\nwrite apps for more then one language,\nget an answer form the NLU back as function value in the control flow of a function,\nuse a global intent for switching a device on or off,\nlet the assistant ask a question and get \"yes\" or \"no\" back as boolean value,\nlet the assistant continue a conversation without the need to utter the, hotword again,\nexecute actions of other skills by submitting intents.","category":"page"},{"location":"details/#Reduce-false-activations-of-intents-by-using-the-same-intent-for-on/off","page":"Some details","title":"Reduce false activations of intents by using the same intent for on/off","text":"","category":"section"},{"location":"details/","page":"Some details","title":"Some details","text":"The on/off-intent, integrated with the SnipsHermesQnD framework, allows for writing apps to power up or down devices, without the need to create a new intent for every device.","category":"page"},{"location":"details/","page":"Some details","title":"Some details","text":"Background: All home assistants run into problems when many intents are responsible to switch on or off a device. Obviously all these intends are very similar and reliable detection of the correct intent is not easy.","category":"page"},{"location":"details/","page":"Some details","title":"Some details","text":"HermesMQTT tries to work around this issue, by using only one intent for all on/off-commands.","category":"page"},{"location":"details/","page":"Some details","title":"Some details","text":"All supported devices are listed in the slot device of the intent Susi:on_off and defined in the slot type device_list in  the profile file `hermes_mqtt.ini.","category":"page"},{"location":"details/","page":"Some details","title":"Some details","text":"If you want to use the intent to swich an additional device on or off","category":"page"},{"location":"details/","page":"Some details","title":"Some details","text":"firstly look in the intent Susi:on_off if the device is already defined in the slot type device_list. If not, you will have to add a new device to the values of the slot type device_list.\nsecondly a my_action_on_of(topic, payload)  function must be defined in the new skill that performs the action. The function must be registered to the  framework by adding a register_on_off_action(my_action_on_of) command to config.jl\nThe framework comes with a function  is_on_off_matched(payload, DEVICE_NAME) which can be called with the current payload and the name (and optionally with the siteId) of the device of interest. It will return one of\n:on, if an \"ON\" is recognised for the device\n:off, if an \"OFF\" is recognised for the device\n:matched, if the device is recognised but no specific on or off\n:unmatched, if the device is not recognised.","category":"page"},{"location":"details/","page":"Some details","title":"Some details","text":"The tutorial shows a simple example how to use this functionality.","category":"page"},{"location":"details/#Reduce-false-activations-of-intents-by-doublechecking-commands","page":"Some details","title":"Reduce false activations of intents by doublechecking commands","text":"","category":"section"},{"location":"details/","page":"Some details","title":"Some details","text":"Intents with simple commands or without slots are sometimes recognised by Snips with high confidence, even if only parts of the command matches. This is because Snips tries to find the best matching intent for every uttered command.","category":"page"},{"location":"details/","page":"Some details","title":"Some details","text":"The HermesMQTT-framework provides a mechanism to cancel intents, recognised by the NLU, by double-checking against ordered lists of words that must be present in a command to be valid.","category":"page"},{"location":"details/","page":"Some details","title":"Some details","text":"This is configured in the config.ini with optional  parameters in each language section of the form:","category":"page"},{"location":"details/","page":"Some details","title":"Some details","text":"<intentname>:must_include = <list of words>\n<intentname>:must_chain = <list of words>\n<intentname>:must_span = <list of words>","category":"page"},{"location":"details/","page":"Some details","title":"Some details","text":"Examples:","category":"page"},{"location":"details/","page":"Some details","title":"Some details","text":"switchOnOff:must_include = on, light\nswitchOnOff:must_include = light, on\nswitchOnOff:must_include = (light|bulb), on","category":"page"},{"location":"details/","page":"Some details","title":"Some details","text":"Several lines of colon-separated parts are possible:","category":"page"},{"location":"details/","page":"Some details","title":"Some details","text":"the first part is the intent name (because one config.ini is responsible for all intents of a skill)\nthe second part must be exactly one of the phrases must_include, must_chain or must_span.\nthe parameter value is a comma-separated list of words or regular expressions.","category":"page"},{"location":"details/","page":"Some details","title":"Some details","text":"For must_include each uttered command must include all words.","category":"page"},{"location":"details/","page":"Some details","title":"Some details","text":"For must_chain each uttered command must include all words and the words must be in the given order.","category":"page"},{"location":"details/","page":"Some details","title":"Some details","text":"For must_span each uttered command must include all words and the words must be in the correct order and they must span the complete command; i.e. the first word in the list must be the first word of the command and the last must be the last one.","category":"page"},{"location":"details/","page":"Some details","title":"Some details","text":"The framework performs this doublecheck before an action is started.  If the complete voice command matches with at least one of the rules the  intent is accepted; if not, the check fails and the session is ended silently.","category":"page"},{"location":"details/#Reduce-false-activations-of-intents-by-disabling-intents","page":"Some details","title":"Reduce false activations of intents by disabling intents","text":"","category":"section"},{"location":"details/","page":"Some details","title":"Some details","text":"Not avaliable yet in v0.9!","category":"page"},{"location":"details/","page":"Some details","title":"Some details","text":"The skill DoNotListen with the intents Susi:DoNotListen and Susi:ListenAgain> can be used to temporarily disable intents.","category":"page"},{"location":"details/","page":"Some details","title":"Some details","text":"The intents themself use strict doublechecking (see section above) to make sure, that only very specific commands are recognised.","category":"page"},{"location":"details/#Ask-and-answer-Yes-or-No","page":"Some details","title":"Ask and answer Yes-or-No","text":"","category":"section"},{"location":"details/","page":"Some details","title":"Some details","text":"An often needed functionality is a quick confirmation feedback of the user. This is provided by the framework function ask_yes_or_no(question).","category":"page"},{"location":"details/","page":"Some details","title":"Some details","text":"See the following self-exlpaining code as example:","category":"page"},{"location":"details/","page":"Some details","title":"Some details","text":"\"\"\"\n    destroy_action(topic, payload)\n\nInitialise self-destruction.\n\"\"\"\nfunction destroy_action(topic, payload)\n\n  # log message:\n  print_log(\"[Susi:DestroyYourself]: action destroy_action() started.\")\n\n  if ask_yes_or_no(\"Do you really want to initiate self-destruction?\")\n    publish_end_session(\"Self-destruction sequence started!\")\n    boom()  # call implementaion\n  else\n    publish_end_session(\"\"\"OK.\n                      Self-destruction sequence is aborted!\n                      Live long and in peace.\"\"\")\n  end\n  return true\nend","category":"page"},{"location":"details/","page":"Some details","title":"Some details","text":"The intent to capture the user response comes with the framework and is activated just for this dialogue.","category":"page"},{"location":"details/#Continue-conversation-without-hotword","page":"Some details","title":"Continue conversation without hotword","text":"","category":"section"},{"location":"details/","page":"Some details","title":"Some details","text":"Sometimes it is necessary to control a device with a sequence of several comands. In this case it is not natural to speak the hotword everytime. like:","category":"page"},{"location":"details/","page":"Some details","title":"Some details","text":"hey Snipsswitch on the lighthey Snipsdim the lighthey Snipsdim the light againhey Snipsdim the light again    ","category":"page"},{"location":"details/","page":"Some details","title":"Some details","text":"Instead, we want something like:","category":"page"},{"location":"details/","page":"Some details","title":"Some details","text":"hey Snipsswitch on the lightdim the lightdim the light againdim the light again    ","category":"page"},{"location":"details/","page":"Some details","title":"Some details","text":"This can be achieved by starting a new session just after an intent is processed. In the HermesMQTT framework this is controlled by two mechanisms:","category":"page"},{"location":"details/","page":"Some details","title":"Some details","text":"The config.jl defines a constant const CONTINUE_WO_HOTWORD = false. false is the default and hence continuation without hotword is disabled by default. To completely disable it for your skill, just set the constant to false.     The second mechanism is the return value of every single skill-action. A new session will only be started if both are true, the constant CONTINUE_WO_HOTWORD and the return value of the function. This way it is possible to decide for each action individually, if a hotword is required for the next command.","category":"page"},{"location":"details/#Multi-language-support","page":"Some details","title":"Multi-language support","text":"","category":"section"},{"location":"details/","page":"Some details","title":"Some details","text":"Multi-language skills need to be able to switch between laguages. In the context of Snips this requires special handling in two cases:","category":"page"},{"location":"details/","page":"Some details","title":"Some details","text":"All text, uttered by the assistant must be defined in all languages.\nAn intent is always tied to one language. Therefore for multi-language skills similar intents (with the same slots) must be created for each supported language.","category":"page"},{"location":"details/","page":"Some details","title":"Some details","text":"Multi-language support ist added in 4 steps:","category":"page"},{"location":"details/#)-Define-language-in-config.ini:","page":"Some details","title":"1) Define language in config.ini:","text":"","category":"section"},{"location":"details/","page":"Some details","title":"Some details","text":"The config.ini must have a line like:","category":"page"},{"location":"details/","page":"Some details","title":"Some details","text":"language=en","category":"page"},{"location":"details/#)-Define-the-texts-snippets-in-all-languages:","page":"Some details","title":"2) Define the texts snippets in all languages:","text":"","category":"section"},{"location":"details/","page":"Some details","title":"Some details","text":"To let the assistant speak different languages, all texts  must be added to a database for all target languages. These are defined in the  config.ini file by connecting a language, a key and the sentence. Text sniplets for each key must be defined in each language:","category":"page"},{"location":"details/","page":"Some details","title":"Some details","text":"[de]\n:skill_echo =  Hallo, ich bin die Hermes-Skill\n:slot_echo_1 = der Wert des Slots\n:slot_echo_2 = ist\n:end_say =     das wars\n:ask_echo_slots = soll ich die Slots des Intent aufsagen?\n:no_slots =    der Intent hat keine Slots\n\n[en]\n:skill_echo =  hello, i am the Hermes skill\n:skill_echo =  i am your new Hermes skill\n:skill_echo =  i am \n:slot_echo_1 = the value of the slot\n:slot_echo_2 = is\n:end_say =     and done\n:ask_echo_slots = do you want me to list the slots of this intent?\n:no_slots =    the intent has no slots\n...","category":"page"},{"location":"details/","page":"Some details","title":"Some details","text":"language: Sentences for each language are defined in sections of        the config file with the 2-character language codes as heading.\nkey: Keys are julia-style Symbols and can be specified with a       leading colon (however this is not mandatory, just good style).       Several sentences can be provided with the same key -        the HermesMQTT.publish_say() will select one of the sentences       randomly.\nsentence: The sentence is added after the = without quoting.","category":"page"},{"location":"details/#)-Create-similar-intents-for-all-languages:","page":"Some details","title":"3) Create similar intents for all languages:","text":"","category":"section"},{"location":"details/","page":"Some details","title":"Some details","text":"The most time-consuming step ist to create the intents in the Snips/Rhasspy console - however this is necessary, because speach-to-text as well as natural language understanding highly depend on the language.","category":"page"},{"location":"details/#)-Switch-between-languages:","page":"Some details","title":"4) Switch between languages:","text":"","category":"section"},{"location":"details/","page":"Some details","title":"Some details","text":"A language can be selected in the config.ini of HermesMQTT or  the config.ini of each skill.","category":"page"},{"location":"details/#)-Utter-texts-in-the-defined-language:","page":"Some details","title":"5) Utter texts in the defined language:","text":"","category":"section"},{"location":"details/","page":"Some details","title":"Some details","text":"In the code, the text sniplets can be used by specifying the keys (as Symbols) just like String literals or values and lined up, such as:","category":"page"},{"location":"details/","page":"Some details","title":"Some details","text":"publish_end_session(\"This is a hard-coded message\")\npublish_end_session(:skill_echo)\npublish_end_session(:skill_echo, \"This is a hard-coded message\")\n\nstr = \"String variable\"\nval = 42\npublish_end_session(:skill_echo, \"and values from variables\", \n                    \"string\", str, \"or value\", val)","category":"page"},{"location":"details/#Publishing-intents-programmically","page":"Some details","title":"Publishing intents programmically","text":"","category":"section"},{"location":"details/","page":"Some details","title":"Some details","text":"Triggers extend the concept of sending MQTT-messages between assistant components to communication between apps or the system or timers and apps.","category":"page"},{"location":"details/","page":"Some details","title":"Some details","text":"By publishing intents from program code, it is possible to","category":"page"},{"location":"details/","page":"Some details","title":"Some details","text":"execute actions in other skills (by publishing the respective intents)\nexecute action at a specified a time with help of the Susi:Schdeule skill.","category":"page"},{"location":"details/#Managing-the-Julia-footprint","page":"Some details","title":"Managing the Julia footprint","text":"","category":"section"},{"location":"details/","page":"Some details","title":"Some details","text":"Unfortunately, the language Julia has a much bigger  footprint as Python, consuming pretty much memory per Julia instance. In consequence it is not possible to run many Julia skills as separate processes, like it is possible with Python programs.","category":"page"},{"location":"details/","page":"Some details","title":"Some details","text":"To work around this issue, all skills within this framework are running in the same Julia procress.  This reduces the footprint as well as the compile times (because the libraries must be compiled only once).","category":"page"},{"location":"details/","page":"Some details","title":"Some details","text":"To run the HermesMQTT skills, all skills must be installed  in directories parallel to HermesMQTT. When the action-*.jl of HermesMQTT is executed, it will load all other loader-*.jl functions and load the skills.","category":"page"},{"location":"details/","page":"Some details","title":"Some details","text":"All skills are executed in parallel  (thanks to Julia this is super easy to implement) and as separate Modules, so that the namespaces are separated and each skill can be implemented without caring about the rest.","category":"page"},{"location":"license/","page":"License","title":"License","text":"The HermesMQTT.jl package is licensed under the MIT License:","category":"page"},{"location":"license/","page":"License","title":"License","text":"Copyright (c) 2023 Andreas Dominik, THM, Gießen, Germany","category":"page"},{"location":"license/","page":"License","title":"License","text":"Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:","category":"page"},{"location":"license/","page":"License","title":"License","text":"The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.","category":"page"},{"location":"license/","page":"License","title":"License","text":"THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.","category":"page"},{"location":"changelog/#ChangeLog-of-HermesMQTT-package","page":"Changelog","title":"ChangeLog of HermesMQTT package","text":"","category":"section"},{"location":"changelog/#ToDo","page":"Changelog","title":"ToDo","text":"","category":"section"},{"location":"changelog/#wip","page":"Changelog","title":"wip","text":"","category":"section"},{"location":"changelog/","page":"Changelog","title":"Changelog","text":"schedule moved to separate skill\ntriggers removed","category":"page"},{"location":"changelog/#v0.8","page":"Changelog","title":"v0.8","text":"","category":"section"},{"location":"changelog/","page":"Changelog","title":"Changelog","text":"inital transfer from ADoSnipHermesQnD","category":"page"},{"location":"install/#Installation","page":"Installation","title":"Installation","text":"","category":"section"},{"location":"install/#Julia","page":"Installation","title":"Julia","text":"","category":"section"},{"location":"install/","page":"Installation","title":"Installation","text":"HermesMQTT is written in the modern programming language Julia (because Julia is faster then Python and coding is much easier and much more straight forward). However \"Pythonians\" often need some time to get familiar with Julia.","category":"page"},{"location":"install/","page":"Installation","title":"Installation","text":"If you are ready for the step forward, start here: https://julialang.org/","category":"page"},{"location":"install/#Installation-of-Julia-language","page":"Installation","title":"Installation of Julia language","text":"","category":"section"},{"location":"install/","page":"Installation","title":"Installation","text":"Installation of Julia is simple:","category":"page"},{"location":"install/","page":"Installation","title":"Installation","text":"just download the tar-ball for your architecture (most probably Raspberry-Pi/arm).\nsave it in an appropriate folder (/opt/Julia/ might be a good idea).\nunpack: tar -xvzf julia-<version>.tar.gz\nmake sure, that the julia executable is executable. You find it as /opt/Julia/julia-<version>/bin/julia. If it is not executable run chmod 755 /opt/Julia/julia-<version>/bin/julia\nAdd a symbolic link from a location which is in the search path, such as /usr/local/bin:","category":"page"},{"location":"install/","page":"Installation","title":"Installation","text":"All together:","category":"page"},{"location":"install/","page":"Installation","title":"Installation","text":"sudo chown $(whoami) /opt    \nmkdir /opt/Julia    \nmv ~/Downloads/julia-<version>.tar.gz .    \ntar -xvzf julia-<version>.tar.gz    \nchmod 755 /opt/Julia/julia-<version>/bin/julia    \ncd /usr/local/bin    \nsudo ln -s /opt/Julia/julia-<version>/bin/julia    ","category":"page"},{"location":"install/","page":"Installation","title":"Installation","text":"... and you are done!","category":"page"},{"location":"install/","page":"Installation","title":"Installation","text":"For a very quick get into, see   learn Julia in Y minutes.","category":"page"},{"location":"install/#IDEs","page":"Installation","title":"IDEs","text":"","category":"section"},{"location":"install/","page":"Installation","title":"Installation","text":"Softwarte development is made comfortable by IDEs (Integrated Development Environements). For Julia, best choices include:","category":"page"},{"location":"install/","page":"Installation","title":"Installation","text":"Visual Studio Code  provides very good support for Julia.\nPlaying around and learning is best done with Jupyter notebooks. The Jupyter stack can be installed easily from the Julia REPL by adding the Package IJulia.","category":"page"},{"location":"install/#Noteworthy-differences-between-Julia-and-Python","page":"Installation","title":"Noteworthy differences between Julia and Python","text":"","category":"section"},{"location":"install/","page":"Installation","title":"Installation","text":"Julia code looks very much like Python code, except of","category":"page"},{"location":"install/","page":"Installation","title":"Installation","text":"there are no colons,\nwhitespaces have no meaning; blocks end with an end,\nsometimes types should be given explicitly (for performance and explicit polymorphism).","category":"page"},{"location":"install/","page":"Installation","title":"Installation","text":"However, Julia is a typed language with all advantages; and code is run-time-compiled only once, with consequences:","category":"page"},{"location":"install/","page":"Installation","title":"Installation","text":"If a function is called for the first time, there is a time lack, because the compiler must finish his work before the actual code starts to execute.\nFuture function calls will use the precompiled machine code, making Julia code execute as fast as compiled c-code!","category":"page"},{"location":"install/#HermesMQTT","page":"Installation","title":"HermesMQTT","text":"","category":"section"},{"location":"install/","page":"Installation","title":"Installation","text":"The framework is installed, by installing the package HermesMQTT.jl. The package is not registered in the official Julia package repository, therefore it must be installed manually:","category":"page"},{"location":"install/","page":"Installation","title":"Installation","text":"using Pkg\nPkg.clone(\"git@github.com:andreasdominik/HermesMQTT.jl.git\")","category":"page"},{"location":"install/","page":"Installation","title":"Installation","text":"find a installation directory;  something like /opt/HermesMQTT or ~/Rhasspy/HermesMQTT may be  good choices.\nrun the installer from a Julia REPL:","category":"page"},{"location":"install/","page":"Installation","title":"Installation","text":"using HermesMQTT\nHermesMQTT.install()","category":"page"},{"location":"install/","page":"Installation","title":"Installation","text":"This will install the package HermesMQTT.jl and all its dependencies. It will also create a directory bin, a file bin/action-hermesMQTT.jl and a file config.ini  in the installation directory. The file action-hermesMQTT.jl  is the loader script.","category":"page"},{"location":"install/","page":"Installation","title":"Installation","text":"Be sure to have a look into the config.ini file and adapt it to your needs (such as MQTT host, port, user, password, etc.).","category":"page"},{"location":"install/","page":"Installation","title":"Installation","text":"The loader script can be used to start the framework. It is a Julia script, which can be run from the Julia REPL or from the command line.  Ideally a service may be created to start the loader script.","category":"page"},{"location":"install/","page":"Installation","title":"Installation","text":"$ julia action-hermesMQTT.jl","category":"page"},{"location":"install/","page":"Installation","title":"Installation","text":"MQTT communication is performed via Eclipse mosquitto client, therefore this must be installed, too. On a Raspberry Pi the packages mosquitto and/or mosquitto-clients are needed:","category":"page"},{"location":"install/","page":"Installation","title":"Installation","text":"$ sudo apt-get install mosquitto\n$ sudo apt-get install mosquitto-clients","category":"page"},{"location":"install/#Skills","page":"Installation","title":"Skills","text":"","category":"section"},{"location":"install/","page":"Installation","title":"Installation","text":"The loader will search for skills in the directory parallel to the HermesMQTT installation. Each Julia-script with a name like loader-<skillname>.jl will be loaded and executed.","category":"page"},{"location":"install/","page":"Installation","title":"Installation","text":"If a skill is hosted at Github, it can be installed by the installSkill(<github-url>) function. It will clone the repository into the correct skills directory or perform an update, if the installation already exists.","category":"page"},{"location":"install/","page":"Installation","title":"Installation","text":"Default-skills (i.e. developed by the author of HermesMQTT) are all in Github repos like git@github.com:andreasdominik/SusiScheduler.git and can be installed with the skill-name:","category":"page"},{"location":"install/","page":"Installation","title":"Installation","text":"\n","category":"page"},{"location":"install/","page":"Installation","title":"Installation","text":"julia install_skill(\"SusiScheduler\")","category":"page"},{"location":"install/#or-with-complete-URL:","page":"Installation","title":"or with complete URL:","text":"","category":"section"},{"location":"install/#","page":"Installation","title":"","text":"","category":"section"},{"location":"install/","page":"Installation","title":"Installation","text":"install_skill(\"git@github.com:andreasdominik/SusiScheduler.git\") ```","category":"page"},{"location":"makeskill/#How-to-write-a-new-skill","page":"New skill tutorial","title":"How to write a new skill","text":"","category":"section"},{"location":"makeskill/","page":"New skill tutorial","title":"New skill tutorial","text":"Because of the fact that all HermesMQTT skills are executed within the same Julia process, there is some more overhead in the code of the skills compared to standalone Python skills.","category":"page"},{"location":"makeskill/","page":"New skill tutorial","title":"New skill tutorial","text":"To support skill development, the framework comes with a generator  script, that creates a skill-skeleton that already is functional without the need of wrinting any code manually.","category":"page"},{"location":"makeskill/","page":"New skill tutorial","title":"New skill tutorial","text":"This brief tutorials guides through the process of making a new skill using the generator script:","category":"page"},{"location":"makeskill/#Set-up-the-framework","page":"New skill tutorial","title":"Set up the framework","text":"","category":"section"},{"location":"makeskill/","page":"New skill tutorial","title":"New skill tutorial","text":"See section Installation for details.  Let us assume, HermesMQTT is installed at /opt/HermesMQTT/.","category":"page"},{"location":"makeskill/#Define-the-intents","page":"New skill tutorial","title":"Define the intents","text":"","category":"section"},{"location":"makeskill/","page":"New skill tutorial","title":"New skill tutorial","text":"It is a good idea, to start skill development in the Rhasspy console (aka web interface) and define the intents  by adding slots and intents to the sentences file or (better) add a new sentences file for each skill.","category":"page"},{"location":"makeskill/","page":"New skill tutorial","title":"New skill tutorial","text":"This way, it is possible to train the speech-to-text engine and  test all wanted commands and to see all generated JSON payloads which your new skill may need to read.","category":"page"},{"location":"makeskill/#Generate-the-skeleton-a-new-project","page":"New skill tutorial","title":"Generate the skeleton a new project","text":"","category":"section"},{"location":"makeskill/","page":"New skill tutorial","title":"New skill tutorial","text":"To generate the skill,  start a Julia REPL and run the skill-generator. The genrator will ask you for the name of the skill, the names of the intents and the names of the slots for each intent.","category":"page"},{"location":"makeskill/","page":"New skill tutorial","title":"New skill tutorial","text":"using HermesMQTT\nHermesMQTT.generate_skill() # or HermesMQTT.generate_skill(\"SkillName\")","category":"page"},{"location":"makeskill/","page":"New skill tutorial","title":"New skill tutorial","text":"The generator asks you to enter","category":"page"},{"location":"makeskill/","page":"New skill tutorial","title":"New skill tutorial","text":"the skill name (if not given as argument),\none by one the intent names for the skill,\nfor each intent, the needed slot names.","category":"page"},{"location":"makeskill/","page":"New skill tutorial","title":"New skill tutorial","text":"The generated skill is functional out of the box. When the HermesMQTT-framework is restarted, it will load the new skill. Because the intents are already defined in Rhasspy, they can be tested instantly.","category":"page"},{"location":"makeskill/","page":"New skill tutorial","title":"New skill tutorial","text":"Of course, the actual implementation of the skill is missing, but if called by the voice command, the new skill will prove that it is alive by telling  you it's name and names and values for all recognised slots.","category":"page"},{"location":"makeskill/#Add-implementation","page":"New skill tutorial","title":"Add implementation","text":"","category":"section"},{"location":"makeskill/","page":"New skill tutorial","title":"New skill tutorial","text":"The actual implementation fo the skill can be added by modifying the  action-functions for each intent. These functions are located in the file Your_Skill/Skill/skill-actions.jl and have the signatures <intentname>_action(topic, payload).","category":"page"},{"location":"makeskill/","page":"New skill tutorial","title":"New skill tutorial","text":"It is easy to change the dummy-implementation into whatever is needed.","category":"page"},{"location":"makeskill/#Files-in-the-sceleton","page":"New skill tutorial","title":"Files in the sceleton","text":"","category":"section"},{"location":"makeskill/","page":"New skill tutorial","title":"New skill tutorial","text":"Although all custom implementation can be done in the file skill-actions.jl, the created skeleton consists of several files.  These may be modified, if wanted:","category":"page"},{"location":"makeskill/","page":"New skill tutorial","title":"New skill tutorial","text":"filename comment needs to be adapted\nloader-MyFire.jl generated loader function for the framework no\nconfig.ini ini file as default yes\napi.jl source code of Julia low-level API for a controlled device optional\nconfig.jl global initialisation of a skill optional\nexported.jl generated exported functions of the skill module no\nskill-actions.jl functions to be executed, if an intent is recognised yes\nMyFire.jl the julia module for the skill no","category":"page"},{"location":"makeskill/","page":"New skill tutorial","title":"New skill tutorial","text":"In a minimum-setup only 2 things need to be adapted for a new skill:","category":"page"},{"location":"makeskill/","page":"New skill tutorial","title":"New skill tutorial","text":"the action-functions which respond to an intent (the direct action, no callback) must be defined and implemented (in skill-actions.jl)\nsettings and sentences to be utterd  in the config.ini-file","category":"page"},{"location":"makeskill/","page":"New skill tutorial","title":"New skill tutorial","text":"Optionally, more fine-grained software engineering is possible by","category":"page"},{"location":"makeskill/","page":"New skill tutorial","title":"New skill tutorial","text":"separating the user-interaction from the API of controlled devices  (the latter might go to api.jl).\nand by using different intents, depending on the language defined in config.ini.","category":"page"},{"location":"makeskill/#Example-with-low-level-API","page":"New skill tutorial","title":"Example with low-level API","text":"","category":"section"},{"location":"makeskill/","page":"New skill tutorial","title":"New skill tutorial","text":"This tutorial shows how a skill to control an external device can be derived from the template.","category":"page"},{"location":"makeskill/","page":"New skill tutorial","title":"New skill tutorial","text":"The idea is to control an Amazon fire stick with a minimum set of commands on, off, play, pause. More commands can be implement easily the same way.","category":"page"},{"location":"makeskill/","page":"New skill tutorial","title":"New skill tutorial","text":"Switching on and off is implemented based on the common on-off-intent, included in the framework.","category":"page"},{"location":"makeskill/#The-Amazon-fire-low-level-API","page":"New skill tutorial","title":"The Amazon fire low-level API","text":"","category":"section"},{"location":"makeskill/","page":"New skill tutorial","title":"New skill tutorial","text":"The low-level API which sends commands to the Amazon fire is borrowed from Matt's ADBee project (git@github.com:mattgyver83/adbee.git) that provides a shell-script to send commands to the Amazon device. Please read there for the steps to prepare the Amazon device for the remote control via ADB.","category":"page"},{"location":"makeskill/","page":"New skill tutorial","title":"New skill tutorial","text":"Although Python programmes usually find Python packages for every task, it is a very good idea to implement the lowest level of any device-control API as a shell script. Advantages:","category":"page"},{"location":"makeskill/","page":"New skill tutorial","title":"New skill tutorial","text":"easy to write\nfast and without any overhead\neasy to test: the API can be tested by running the script from the commandline as controlFire ON or controlFire OFF and see what happens.","category":"page"},{"location":"makeskill/","page":"New skill tutorial","title":"New skill tutorial","text":"The simplified ADBee-script is:","category":"page"},{"location":"makeskill/","page":"New skill tutorial","title":"New skill tutorial","text":"#!/bin/bash -xv\n# control fireTv via adb\n\nCOMMANDS=$@\nIP=amazon-fire  # set to 192.168.1.200 by dhcp\nPORT=5555\nADB=adb\nSEND_KEY=\"$ADB -s $IP:$PORT shell input keyevent\"\n\nadb connect amazon-fire\n\nfor CMD in $COMMANDS ; do\n  case $CMD in\n    wake)\n      $SEND_KEY KEYCODE_WAKEUP\n      ;;\n    sleep)\n      $SEND_KEY KEYCODE_POWER\n      ;;\n    play)\n      $SEND_KEY KEYCODE_MEDIA_PLAY_PAUSE\n      ;;\n    pause)\n      $SEND_KEY KEYCODE_MEDIA_PLAY_PAUSE\n      ;;\n    # more commands may go here ...\n  esac\ndone","category":"page"},{"location":"makeskill/","page":"New skill tutorial","title":"New skill tutorial","text":"Once this script is tested, the Julia API can be set up.","category":"page"},{"location":"makeskill/#The-Julia-API","page":"New skill tutorial","title":"The Julia API","text":"","category":"section"},{"location":"makeskill/","page":"New skill tutorial","title":"New skill tutorial","text":"By default the API goes into the file api.jl, which is empty in the template.","category":"page"},{"location":"makeskill/","page":"New skill tutorial","title":"New skill tutorial","text":"In this case only a wrapper is needed, to make the API-commands available in the Julia program. The framework provide a function tryrun() to execute external commands safely (i.e. if an error occures, the program will not crash, but reading the error message via Hermes text-to-speech).","category":"page"},{"location":"makeskill/","page":"New skill tutorial","title":"New skill tutorial","text":"This API definition splits in the function to execute the ADBee-script and functions to be called by the user:","category":"page"},{"location":"makeskill/","page":"New skill tutorial","title":"New skill tutorial","text":"function adbCmds(cmds)\n\n    return tryrun(`$ADB $(split(cmds))`, errorMsg =\n            \"\"\"An error occured while sending commands $cmds\n            to Amazon fire.\"\"\"\nend\n\n\n\n\nfunction amazonON()\n    adbCmds(\"wake\")\nend\n\nfunction amazonOFF()\n    adbCmds(\"sleep\")\nend\n\nfunction amazonPlay()\n    adbCmds(\"play\")\nend\n\nfunction amazonPause()\n    adbCmds(\"pause\")\nend","category":"page"},{"location":"makeskill/#The-skill-action-for-on/off","page":"New skill tutorial","title":"The skill-action for on/off","text":"","category":"section"},{"location":"makeskill/","page":"New skill tutorial","title":"New skill tutorial","text":"This functions are executed by the framework if an intent is recognised. The functions are defined in the file skill-actions.jl. On/off is handled via the common on/off-intent. All other actions need a specific intent, that must be set up in the Snips console.","category":"page"},{"location":"makeskill/","page":"New skill tutorial","title":"New skill tutorial","text":"The constants DEVICE_NAME and SLOT_NAME, used in the example,  can be defined somewhere (by default constants are defined in config.jl):","category":"page"},{"location":"makeskill/","page":"New skill tutorial","title":"New skill tutorial","text":"\"\"\"\n    power_on_off(topic, payload)\n\nPower on or of with HermesMQTT mechanism.\n\"\"\"\nfunction power_on_off(topic, payload)\n\n    if is_on_off_matched(payload, DEVICE_NAME) == :on\n        publish_end_session(\"I wake up the Amazon Fire Stick.\")\n        amazonON()\n        return true\n\n    elseif is_on_off_matched(payload, DEVICE_NAME) == :off\n        publish_end_session(\"I send the Amazon Fire Stick to sleep.\")\n        amazonOFF()\n        return true\n\n    else\n        return false\n    end\nend","category":"page"},{"location":"makeskill/","page":"New skill tutorial","title":"New skill tutorial","text":"Returning false will disable the continue without hotword function; i.e. a hotword is necessary before the next command can be uttered. This is necessary for the default-case, because probably a different app will execute this non-recognised command.","category":"page"},{"location":"makeskill/#The-skill-action-for-all-other-commands","page":"New skill tutorial","title":"The skill-action for all other commands","text":"","category":"section"},{"location":"makeskill/","page":"New skill tutorial","title":"New skill tutorial","text":"All other commands must be handled by an intent that you must create in the Rhasspy console. Let's assume the intent has the name MyFire and delivers the command in the slot Command. The slot should know all known commands with synonyms.","category":"page"},{"location":"makeskill/","page":"New skill tutorial","title":"New skill tutorial","text":"If the intend have not been already generated, a  skill-action has to be defined in the file skill-actions.jl:","category":"page"},{"location":"makeskill/","page":"New skill tutorial","title":"New skill tutorial","text":"\"\"\"\n    action_commands(topic, payload)\n\nSend commands to Amamzon device.\n\"\"\"\nfunction action_commands(topic, payload)\n\n    if is_in_slot(SLOT_NAME, \"play\")\n        publish_end_session(\"I play the current selection!\")\n        amazonPlay()\n        return true\n\n    elseif is_in_slot(SLOT_NAME, \"pause\")\n        publish_end_session(\"I pause the movie.\")\n        amazonPause()\n        return true\n\n    else\n        publish_end_session(\"I cannot respond!\")\n        return true\n    end\nend","category":"page"},{"location":"makeskill/#Tying-everything-together","page":"New skill tutorial","title":"Tying everything together","text":"","category":"section"},{"location":"makeskill/","page":"New skill tutorial","title":"New skill tutorial","text":"The last step is to tell the skill the names of intents to listen to and the names of the slots to extract values from. Both is defined in the file config.jl:","category":"page"},{"location":"makeskill/","page":"New skill tutorial","title":"New skill tutorial","text":"The slot names are simply defined as global constants (they are only global within the module MyFire).\nIntents and respective functions are stored in the background and registered with the function register_intent_action(). (the generator script is doing this registration for you)","category":"page"},{"location":"makeskill/","page":"New skill tutorial","title":"New skill tutorial","text":"const SLOT_NAME = \"Command\"\nconst DEVICE_NAME = \"amazon_fire\"\n\n...\n\nregister_on_off_action(power_on_off)\nregister_intent_action(\"MyFire\", action_commands)","category":"page"},{"location":"makeskill/","page":"New skill tutorial","title":"New skill tutorial","text":"Once the functuions are registered together with the intents, the framework will execute the functions.","category":"page"},{"location":"#HermesMQTT","page":"Introduction","title":"HermesMQTT","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"This is a \"quick-and-Dirty\" framework for Snips.ai-style home assistants  (such as Rhasspy) written in Julia. It comes with generator script which can be used as starting point for own skills.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"To learn about Snips, goto snips.ai.    ","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"To learn about Rhasspy, goto  rhasspy.       ","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"To get introduced with Julia, see julialang.org.","category":"page"},{"location":"#Similarities-and-differences-to-the-Hermes-dialogue-manager","page":"Introduction","title":"Similarities and differences to the Hermes dialogue manager","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"The framework allows for setting up skills/apps the same way as with the Python libraries. However, according to the more functional programming style in Julia, more direct interactions are provided and technical stuff (such as siteId, sessionId, callback-functions, etc.) are handled transparently by the framework in the background.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"As an example, the function listen_intents_one_time() can be used without a callback-function. Recognised intent and payload are returned as function value.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"On top of listen_intents_one_time(), HermesMQTT comes with a simple question/answer methods to ask questions answered with Yes or No (ask_yes_or_no() and ask_yes_or_no_or_unknown()). As a result, it is possible to get a quick user-feedback without leaving the control flow of a function.","category":"page"}]
}
